package com.wireanno.processor;


import com.wireanno.*;
import com.wireanno.processor.types.FixedAsciiTypeProcessor;

import javax.annotation.processing.*;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.*;
import javax.lang.model.util.Elements;
import javax.tools.Diagnostic;
import javax.tools.JavaFileObject;
import java.io.IOException;
import java.io.Writer;
import java.util.*;

@SupportedAnnotationTypes({
    "com.wireanno.Message",
    "com.wireanno.UInt16Field",
    "com.wireanno.UInt32Field",
    "com.wireanno.Float32Field",
    "com.wireanno.FixedAsciiField"
})

@SupportedSourceVersion(SourceVersion.RELEASE_8)
public class WireAnnoProcessor extends AbstractProcessor {

    private Filer filer;
    private Elements elements;
    private Messager messager;

    @Override
    public synchronized void init(ProcessingEnvironment env) {
        super.init(env);
        this.filer = env.getFiler();
        this.elements = env.getElementUtils();
        this.messager = env.getMessager();
    }

    @Override
    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
        Set<? extends Element> types = roundEnv.getElementsAnnotatedWith(Message.class);
        for (Element type : types) {
            if (type.getKind() != ElementKind.INTERFACE) {
                messager.printMessage(Diagnostic.Kind.ERROR, "@Message must be placed on an interface", type);
                continue;
            }
            try {
                generateSerializer((TypeElement) type);
            } catch (IOException e) {
                messager.printMessage(Diagnostic.Kind.ERROR, "Generation failed: " + e.getMessage(), type);
            }
        }
        return false; // allow other processors
    }

    private void generateSerializer(TypeElement iface) throws IOException {
        String pkg = elements.getPackageOf(iface).getQualifiedName().toString();
        String ifaceName = iface.getSimpleName().toString();
        String serializerName = ifaceName + "WireAnnoSerializer";
        Endian defaultEndian = iface.getAnnotation(Message.class).endian();

        // Collect annotated methods and sort by "fieldNum"
        List<VariableElement> fields = new ArrayList<VariableElement>();
        for (Element e : iface.getEnclosedElements()) {
            if (e.getKind() == ElementKind.FIELD) {
                VariableElement f = (VariableElement) e;
                if (hasAnyFieldAnnotation(f)) {
                    fields.add(f);
                }
            }
        }
        Collections.sort(fields, new Comparator<VariableElement>() {
            public int compare(VariableElement a, VariableElement b) {
                int na = fieldNumOf(a);
                int nb = fieldNumOf(b);
                return na < nb ? -1 : (na == nb ? 0 : 1);
            }
        });

        // Build the source (plain StringBuilder for Java 8)
        String qName = pkg.length() == 0 ? serializerName : (pkg + "." + serializerName);
        JavaFileObject file = filer.createSourceFile(qName, iface);

        Writer w = file.openWriter();
        try {
            StringBuilder sb = new StringBuilder();
            if (pkg.length() != 0) {
                sb.append("package ").append(pkg).append(";\n\n");
            }
            sb.append("import java.nio.ByteBuffer;\n");
            sb.append("import java.nio.charset.StandardCharsets;\n");
            sb.append("import java.util.Map;\n");
            sb.append("import java.util.LinkedHashMap;\n");
            sb.append("\n");
            sb.append("/** Generated by WireAnnotations (Java 8). */\n");
            sb.append("public final class ").append(serializerName).append(" {\n");

            // encode method
            sb.append("  public static byte[] encode(").append(ifaceName).append(" instance) throws Exception {\n");
            sb.append("    int total = 0;\n");
            for (VariableElement m : fields) {
                if (m.getAnnotation(FixedAsciiField.class) != null) {
                    FixedAsciiField fas = m.getAnnotation(FixedAsciiField.class);
                    sb.append("    total += ").append(fas.length()).append(";\n");
                } else if (m.getAnnotation(UInt16Field.class) != null) {
                    sb.append("    total += 2;\n");
                } else if (m.getAnnotation(UInt32Field.class) != null) {
                    sb.append("    total += 4;\n");
                } else if (m.getAnnotation(Float32Field.class) != null) {
                    sb.append("    total += 4;\n");
                }
            }
            sb.append("    ByteBuffer buf = ByteBuffer.allocate(total);\n");
            for (VariableElement m : fields) {
                String name = m.getSimpleName().toString();
                if (m.getAnnotation(UInt16Field.class) != null) {
                    sb.append("    buf.putShort((short)(instance.").append(name).append("() & 0xFFFF));\n");
                } else if (m.getAnnotation(UInt32Field.class) != null) {
                    sb.append("    buf.putInt((int)(instance.").append(name).append("() & 0xFFFF_FFFFL));\n");
                } else if (m.getAnnotation(Float32Field.class) != null) {
                    sb.append("    buf.putFloat(instance.").append(name).append("());\n");
                } else {
                    FixedAsciiField fas = m.getAnnotation(FixedAsciiField.class);
                    if (fas != null) {
                        sb.append("    byte[] raw_").append(name).append(" = instance.").append(name)
                          .append("() == null ? new byte[0] : instance.").append(name)
                          .append("().getBytes(StandardCharsets.US_ASCII);\n");
                        sb.append("    if (raw_").append(name).append(".length > ").append(fas.length())
                          .append(") throw new IllegalArgumentException(\"").append(name)
                          .append(" too long\");\n");
                        sb.append("    buf.put(raw_").append(name).append(");\n");
                        sb.append("    for (int i = raw_").append(name).append(".length; i < ")
                          .append(fas.length()).append("; i++) buf.put((byte)").append((int) fas.pad()).append(");\n");
                    }
                }
            }
            sb.append("    return buf.array();\n");
            sb.append("  }\n\n");

            // decode method -> Map<String,Object>
            sb.append("  public static Map<String,Object> decode(byte[] bytes) throws Exception {\n");
            sb.append("    Map<String,Object> out = new LinkedHashMap<String,Object>();\n");
            sb.append("    ByteBuffer buf = ByteBuffer.wrap(bytes);\n");
            for (VariableElement m : fields) {
                String name = m.getSimpleName().toString();
                if (m.getAnnotation(UInt16Field.class) != null) {
                    sb.append("    out.put(\"").append(name).append("\", buf.getShort() & 0xFFFF);\n");
                } else if (m.getAnnotation(UInt32Field.class) != null) {
                    sb.append("    out.put(\"").append(name).append("\", buf.getInt() & 0xFFFF_FFFFL);\n");
                } else if (m.getAnnotation(Float32Field.class) != null) {
                    sb.append("    out.put(\"").append(name).append("\", buf.getFloat());\n");
                } else {
                    FixedAsciiField fas = m.getAnnotation(FixedAsciiField.class);
                    if (fas != null) {
                        sb.append("    byte[] d_").append(name).append(" = new byte[").append(fas.length()).append("];\n");
                        sb.append("    buf.get(d_").append(name).append(");\n");
                        sb.append("    int end_").append(name).append(" = d_").append(name).append(".length;\n");
                        sb.append("    while (end_").append(name).append(" > 0 && d_").append(name)
                          .append("[end_").append(name).append(" - 1] == (byte)").append((int) fas.pad()).append(") end_")
                          .append(name).append("--;\n");
                        sb.append("    out.put(\"").append(name).append("\", new String(d_").append(name)
                          .append(", 0, end_").append(name).append(", StandardCharsets.US_ASCII));\n");
                    }
                }
            }
            sb.append("    return out;\n");
            sb.append("  }\n");

            sb.append("}\n");

            w.write(sb.toString());
        } finally {
            w.close();
        }
    }

    private boolean hasAnyFieldAnnotation(VariableElement m) {
        return m.getAnnotation(UInt16Field.class) != null
            || m.getAnnotation(UInt32Field.class) != null
            || m.getAnnotation(Float32Field.class) != null
            || m.getAnnotation(FixedAsciiField.class) != null;
    }

    private int fieldNumOf(VariableElement m) {
        UInt16Field u16 = m.getAnnotation(UInt16Field.class);
        if (u16 != null) return u16.fieldNum();
        UInt32Field u32 = m.getAnnotation(UInt32Field.class);
        if (u32 != null) return u32.fieldNum();
        FixedAsciiField fas = m.getAnnotation(FixedAsciiField.class);
        if (fas != null) return fas.fieldNum();
        Float32Field f32 = m.getAnnotation(Float32Field.class);
        if (f32 != null) return f32.fieldNum();
        return Integer.MAX_VALUE;
    }
}